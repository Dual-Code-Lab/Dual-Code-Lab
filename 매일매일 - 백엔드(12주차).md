### **OSIV란? (**2024/11/08**)**

osiv란 화면단까지 영속성을 열어두는것이다. 영속성은 트랜잭션안에서만 유지되게 되어있다. 하지만 osiv전략에서는 트랜잭션 밖에서도 이용할 수 있도록 되어있다. 방법은 간단하다. 프로젝트의 설정파일에 spring.jpa.open-in-view: false로 해주면 된다.(기본으로 true). 기본적으로 우리는 @Transacton을 비지니스 로직에 적어 트랜잭션의 범위를 정해준다. 하지만 OSIV전략에선 Controller, View단까지 영속성을 유지하면서 지연로딩을 통해  좀 더 유연하게 영속성에 올라가 있는 entity를 관리 할 수 있다. 

영속성을 넓은 범위에서 사여용할 수 있다는 좋은 장점이 있다. 하지만 좋은 점이 있으면 나쁜점이 있듯이 영속성을 뷰까지 유지하면서 db와의 커낵션을 계속 유지해야한다는 것이다. 즉  화면에서 응답을 받을때 까지 1:1로 db와 커넥션을 계~~속 유지하고 있다는 것이다. 이런식이면 트래픽이 많은 경우 자원부족으로 에러가 발생할 수 가 있다.

무작정 osiv전략을 이용한다기 보단 상황에 맞게 사용하지 말지를 정해야하는 기능이다.

### **RAID란? (**2024/11/11**)**

데이터를 저장할때 여러 하드디스크나 SSD를 **하나의** 저장장치처럼 사용하는기능입니다.

큰데이터를 여러개의 저장매체에 저장함으로써 데이터를 분산하여 데이트를 읽어올때 보다 빠르게 데이터를 읽어올수 있게 해줍니다. 하지만 초기버전은 데이터를 제대로 저장하지 못했을 겨우에 데이터를 복구하거나 수정할 수 가 없습니다. 그리하여 새로 나온 버전들에서는 미러링을 통하여 복사본데이터를 저장하여 보다 안전하게 데이터를 저장할 수 있도록 나왔습니다.

### @VALUE사용시 주의사항은? (2024/11/12)

@VAELU는 설정파일에 있는 값을 불러오는것이다. 대표적으로 주의해야할점은 주입시점인데, 컴포넌트가 스프링빈으로 등록된 후 의존관계를 주입할때 값을 할당합니다. 즉 @Component를 사용하지않아 컴포넌트로 선언이 안되 있을경우에는 값을 찾아오지못한다는 점입니다.

→ **`@ConfigurationProperties` 어노테이션과의 차이점은 무엇인가요? 🤔**

 파일에서 값을 불러온다는 점은 동일하지만 **`@ConfigurationProperties` 는 Reraxing Binding**을 한다는 점입니다. 변수가 어느정도 비슷하면 그 값으로 인정하고 그 값을 찾아옵니다. 좀 더 유연적으로 인식하고데이터를 받아옵니다.

### **ExceptionHandler은 어떻게 작동하나요?** (2024/11/13)

Controller단에서 발생하는 에러를 처리해주는 어노테이션 입니다. Controller단에서 좀 더 파악하기 쉽게 예외처리를 보여 줄 수 있습니다. MVC실행 과정중 에러 발생시 Dispacher Servlet이 알맞은 HandlerException을 찾아와 예외를 처리해줍니다. 가장먼저 ExceptionHandlerExceptionResolver가 동작하여 발생한 예외가 @ExceptionHandler에 등록이 되어있는지 확인합니다. 그 후 등록된 예외를 터트려줍니다

### **@ResponseBody(or ResponseEntity<T>)가 있을 때와 없을 때의 동작 방식의 차이점을 말해주세요.** (2024/11/14)

있을 경우에는 값을 리턴할때 HTTP형식에 맞게 데이터를 전송합니다. java객체는 json,xml타입을 변환하여 값을 전달해줍니다.

없을 경우에는 리턴값을 뷰의 이름으로 해석합니다. 뷰리졸버로 뷰를 찾고 응답합니다.

### **Spring Data JPA에서 새로운 Entity인지 판단하는 방법은 무엇일까요?** (2024/11/15)

isNew함수를 사용하여 판답합니다. @Version이 없거나 값이 private이면 AbstractEntityInformation의 isNew를 실행합니다. @Id가 선언된 변수를 찾은 후  @GenerateValue가 선언되어 있는지 아닌지를 파악한다.

그 후 @GenerateValue는 DB에서 아이디값을 초기화 해주기떄문에 isNew함수로 새로만든 entity의 확인이 가능하다.

→id값을 직접 할당하는 entity라면? Persistable<T>를 임플리먼트하여 직접구현해야할것이다.
